{"ast":null,"code":"export const sortStore = [{\n  sortHeader: 'Insertion Sort',\n  name: 'INSERTION_SORT',\n  code: `\n    public static void insertionSort(int[] arr) {\n      int n = arr.length;\n      for (int i = 1; i < n; i++) {\n          int key = arr[i];\n          int j = i - 1;\n          while (j >= 0 && arr[j] > key) {\n              arr[j + 1] = arr[j];\n              j = j - 1;\n          }\n          arr[j + 1] = key;\n      }\n    }\n    `\n}, {\n  sortHeader: 'Selection Sort',\n  name: 'SELECTION_SORT',\n  code: `\n    public static void selectionSort(int[] arr) {\n      int n = arr.length;\n\n      for (int i = 0; i < n-1; i++) {\n          int minIndex = i;\n\n          for (int j = i+1; j < n; j++) {\n              if (arr[j] < arr[minIndex]) {\n                  minIndex = j;\n              }\n          }\n          int temp = arr[minIndex];\n          arr[minIndex] = arr[i];\n          arr[i] = temp;\n      }\n    }\n    `\n}, {\n  sortHeader: 'Bubble Sort',\n  name: 'BUBBLE_SORT',\n  code: `\n    public static void modifiedBubbleSort(int[] arr) {\n      int n = arr.length;\n      boolean swapped;\n\n      for (int i = 0; i < n-1; i++) {\n          swapped = false;\n\n          for (int j = 0; j < n-i-1; j++) {\n              if (arr[j] > arr[j+1]) {\n                  // Swap arr[j] and arr[j+1]\n                  int temp = arr[j];\n                  arr[j] = arr[j+1];\n                  arr[j+1] = temp;\n                  swapped = true;\n              }\n          }\n\n          // If no two elements were swapped, then the array is already sorted\n          if (!swapped) {\n              break;\n          }\n      }\n    }\n    `\n}, {\n  sortHeader: 'Merge Sort',\n  name: 'MERGE_SORT',\n  code: `\n    public static void mergeSort(int[] arr) {\n      if (arr.length < 2) {\n          return;\n      }\n\n      int mid = arr.length / 2;\n      int[] left = new int[mid];\n      int[] right = new int[arr.length - mid];\n\n      System.arraycopy(arr, 0, left, 0, mid);\n      System.arraycopy(arr, mid, right, 0, arr.length - mid);\n\n      mergeSort(left);\n      mergeSort(right);\n      merge(arr, left, right);\n    }\n\n    private static void merge(int[] arr, int[] left, int[] right) {\n      int i = 0, j = 0, k = 0;\n\n      while (i < left.length && j < right.length) {\n          if (left[i] <= right[j]) {\n              arr[k++] = left[i++];\n          } else {\n              arr[k++] = right[j++];\n          }\n      }\n\n      while (i < left.length) {\n          arr[k++] = left[i++];\n      }\n\n      while (j < right.length) {\n          arr[k++] = right[j++];\n      }\n  }\n  `\n}, {\n  sortHeader: 'Quick Sort',\n  name: 'QUICK_SORT',\n  code: `public static void quickSort(int[] arr, int low, int high) {\n      if (low < high) {\n          int pi = partition(arr, low, high);\n\n          quickSort(arr, low, pi - 1);\n          quickSort(arr, pi + 1, high);\n      }\n    }\n\n    private static int partition(int[] arr, int low, int high) {\n      int pivot = arr[high];\n      int i = low - 1;\n\n      for (int j = low; j < high; j++) {\n          if (arr[j] < pivot) {\n              i++;\n\n              int temp = arr[i];\n              arr[i] = arr[j];\n              arr[j] = temp;\n          }\n      }\n\n      int temp = arr[i + 1];\n      arr[i + 1] = arr[high];\n      arr[high] = temp;\n\n      return i + 1;\n    }`\n}];","map":{"version":3,"names":["sortStore","sortHeader","name","code"],"sources":["/Users/gvkoundinya/Desktop/Projects/sorting-visualizer/src/assets/static/data.ts"],"sourcesContent":["import { ISortType } from \"../../Model/appModel\";\n\nexport const sortStore: ISortType[] = [\n  {\n    sortHeader: 'Insertion Sort',\n    name: 'INSERTION_SORT',\n    code:`\n    public static void insertionSort(int[] arr) {\n      int n = arr.length;\n      for (int i = 1; i < n; i++) {\n          int key = arr[i];\n          int j = i - 1;\n          while (j >= 0 && arr[j] > key) {\n              arr[j + 1] = arr[j];\n              j = j - 1;\n          }\n          arr[j + 1] = key;\n      }\n    }\n    `\n  },\n  {\n    sortHeader: 'Selection Sort',\n    name: 'SELECTION_SORT',\n    code: `\n    public static void selectionSort(int[] arr) {\n      int n = arr.length;\n\n      for (int i = 0; i < n-1; i++) {\n          int minIndex = i;\n\n          for (int j = i+1; j < n; j++) {\n              if (arr[j] < arr[minIndex]) {\n                  minIndex = j;\n              }\n          }\n          int temp = arr[minIndex];\n          arr[minIndex] = arr[i];\n          arr[i] = temp;\n      }\n    }\n    `\n  },\n  {\n    sortHeader: 'Bubble Sort',\n    name: 'BUBBLE_SORT',\n    code: `\n    public static void modifiedBubbleSort(int[] arr) {\n      int n = arr.length;\n      boolean swapped;\n\n      for (int i = 0; i < n-1; i++) {\n          swapped = false;\n\n          for (int j = 0; j < n-i-1; j++) {\n              if (arr[j] > arr[j+1]) {\n                  // Swap arr[j] and arr[j+1]\n                  int temp = arr[j];\n                  arr[j] = arr[j+1];\n                  arr[j+1] = temp;\n                  swapped = true;\n              }\n          }\n\n          // If no two elements were swapped, then the array is already sorted\n          if (!swapped) {\n              break;\n          }\n      }\n    }\n    `\n  },\n  {\n    sortHeader: 'Merge Sort',\n    name: 'MERGE_SORT',\n    code: `\n    public static void mergeSort(int[] arr) {\n      if (arr.length < 2) {\n          return;\n      }\n\n      int mid = arr.length / 2;\n      int[] left = new int[mid];\n      int[] right = new int[arr.length - mid];\n\n      System.arraycopy(arr, 0, left, 0, mid);\n      System.arraycopy(arr, mid, right, 0, arr.length - mid);\n\n      mergeSort(left);\n      mergeSort(right);\n      merge(arr, left, right);\n    }\n\n    private static void merge(int[] arr, int[] left, int[] right) {\n      int i = 0, j = 0, k = 0;\n\n      while (i < left.length && j < right.length) {\n          if (left[i] <= right[j]) {\n              arr[k++] = left[i++];\n          } else {\n              arr[k++] = right[j++];\n          }\n      }\n\n      while (i < left.length) {\n          arr[k++] = left[i++];\n      }\n\n      while (j < right.length) {\n          arr[k++] = right[j++];\n      }\n  }\n  `\n  },\n  {\n    sortHeader: 'Quick Sort',\n    name: 'QUICK_SORT',\n    code: `public static void quickSort(int[] arr, int low, int high) {\n      if (low < high) {\n          int pi = partition(arr, low, high);\n\n          quickSort(arr, low, pi - 1);\n          quickSort(arr, pi + 1, high);\n      }\n    }\n\n    private static int partition(int[] arr, int low, int high) {\n      int pivot = arr[high];\n      int i = low - 1;\n\n      for (int j = low; j < high; j++) {\n          if (arr[j] < pivot) {\n              i++;\n\n              int temp = arr[i];\n              arr[i] = arr[j];\n              arr[j] = temp;\n          }\n      }\n\n      int temp = arr[i + 1];\n      arr[i + 1] = arr[high];\n      arr[high] = temp;\n\n      return i + 1;\n    }`\n  }\n];"],"mappings":"AAEA,OAAO,MAAMA,SAAsB,GAAG,CACpC;EACEC,UAAU,EAAE,gBAAgB;EAC5BC,IAAI,EAAE,gBAAgB;EACtBC,IAAI,EAAE;AACV;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC,EACD;EACEF,UAAU,EAAE,gBAAgB;EAC5BC,IAAI,EAAE,gBAAgB;EACtBC,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC,EACD;EACEF,UAAU,EAAE,aAAa;EACzBC,IAAI,EAAE,aAAa;EACnBC,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC,EACD;EACEF,UAAU,EAAE,YAAY;EACxBC,IAAI,EAAE,YAAY;EAClBC,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC,EACD;EACEF,UAAU,EAAE,YAAY;EACxBC,IAAI,EAAE,YAAY;EAClBC,IAAI,EAAG;AACX;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACE,CAAC,CACF"},"metadata":{},"sourceType":"module","externalDependencies":[]}